// Generated by Melange
'use strict';

const Curry = require("melange.js/curry.js");

function negb(param) {
  if (param) {
    return false;
  } else {
    return true;
  }
}

function app(l, m) {
  if (l) {
    return {
      hd: l.hd,
      tl: app(l.tl, m)
    };
  } else {
    return m;
  }
}

function forallb(f, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return true;
    }
    if (!Curry._1(f, param.hd)) {
      return false;
    }
    _param = param.tl;
    continue;
  };
}

function filter(f, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return /* [] */ 0;
    }
    const l0 = param.tl;
    const x = param.hd;
    if (Curry._1(f, x)) {
      return {
        hd: x,
        tl: filter(f, l0)
      };
    }
    _param = l0;
    continue;
  };
}

function memB_list(eqb, _xs, x) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return false;
    }
    if (Curry._2(eqb, x, xs.hd)) {
      return true;
    }
    _xs = xs.tl;
    continue;
  };
}

function memB_list_correct(eqb, eqb_spec, _xs, x) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return /* ReflectF */ 1;
    }
    const r = Curry._2(eqb_spec, x, xs.hd);
    if (r === /* ReflectT */ 0) {
      return /* ReflectT */ 0;
    }
    _xs = xs.tl;
    continue;
  };
}

const FiniteDomainHelpers = {
  memB_list: memB_list,
  memB_list_correct: memB_list_correct
};

function values_list(d) {
  return d.values;
}

const FiniteDomainModel = {
  values_list: values_list
};

function memB_list$1(eqb, _xs, x) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return false;
    }
    if (Curry._2(eqb, x, xs.hd)) {
      return true;
    }
    _xs = xs.tl;
    continue;
  };
}

function memB_list_correct$1(eqb, eqb_spec, _xs, x) {
  while (true) {
    const xs = _xs;
    if (!xs) {
      return /* ReflectF */ 1;
    }
    const r = Curry._2(eqb_spec, x, xs.hd);
    if (r === /* ReflectT */ 0) {
      return /* ReflectT */ 0;
    }
    _xs = xs.tl;
    continue;
  };
}

function universe(d) {
  return d.universe;
}

function values(d) {
  return d.values;
}

function universe_list(d) {
  return d.universe;
}

function values_list$1(d) {
  return d.values;
}

function isEmpty(d) {
  const match = d.values;
  if (match) {
    return false;
  } else {
    return true;
  }
}

function isDefinedAt(eqb, d, x) {
  return memB_list(eqb, d.values, x);
}

function isSubsetOf(eqb, a, b) {
  return forallb((function (v) {
    return isDefinedAt(eqb, b, v);
  }), a.values);
}

function isSupersetOf(eqb, a, b) {
  return isSubsetOf(eqb, b, a);
}

function equals(eqb, a, b) {
  if (isSubsetOf(eqb, a, b)) {
    return isSubsetOf(eqb, b, a);
  } else {
    return false;
  }
}

function union(a, b) {
  return {
    universe: app(a.values, b.values),
    values: app(a.values, b.values)
  };
}

function intersection(eqb, a, b) {
  return {
    universe: a.universe,
    values: filter((function (v) {
      return isDefinedAt(eqb, b, v);
    }), a.values)
  };
}

function difference(eqb, a, b) {
  return {
    universe: a.universe,
    values: filter((function (v) {
      const param = isDefinedAt(eqb, b, v);
      if (param) {
        return false;
      } else {
        return true;
      }
    }), a.values)
  };
}

function complement(eqb, d) {
  return {
    universe: d.universe,
    values: filter((function (v) {
      const param = isDefinedAt(eqb, d, v);
      if (param) {
        return false;
      } else {
        return true;
      }
    }), d.universe)
  };
}

function mem_decidable(eqb, eqb_spec, d, x) {
  const r = memB_list_correct(eqb, eqb_spec, d.values, x);
  if (r === /* ReflectT */ 0) {
    return true;
  } else {
    return false;
  }
}

const FiniteDomain = {
  memB_list: memB_list$1,
  memB_list_correct: memB_list_correct$1,
  universe: universe,
  values: values,
  universe_list: universe_list,
  values_list: values_list$1,
  isEmpty: isEmpty,
  isDefinedAt: isDefinedAt,
  isSubsetOf: isSubsetOf,
  isSupersetOf: isSupersetOf,
  equals: equals,
  union: union,
  intersection: intersection,
  difference: difference,
  complement: complement,
  mem_decidable: mem_decidable
};

const FD = FiniteDomain;

module.exports = {
  negb,
  app,
  forallb,
  filter,
  FiniteDomainHelpers,
  FiniteDomainModel,
  FiniteDomain,
  FD,
}
/* No side effect */
