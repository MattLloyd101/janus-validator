// Generated by Melange
'use strict';

const Curry = require("melange.js/curry.js");

function app(l, m) {
  if (l) {
    return {
      hd: l.hd,
      tl: app(l.tl, m)
    };
  } else {
    return m;
  }
}

function compOpp(param) {
  switch (param) {
    case /* Eq */ 0 :
      return /* Eq */ 0;
    case /* Lt */ 1 :
      return /* Gt */ 2;
    case /* Gt */ 2 :
      return /* Lt */ 1;
  }
}

function flat_map(f, param) {
  if (param) {
    return app(Curry._1(f, param.hd), flat_map(f, param.tl));
  } else {
    return /* [] */ 0;
  }
}

function existsb(f, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return false;
    }
    if (Curry._1(f, param.hd)) {
      return true;
    }
    _param = param.tl;
    continue;
  };
}

function filter(f, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return /* [] */ 0;
    }
    const l0 = param.tl;
    const x = param.hd;
    if (Curry._1(f, x)) {
      return {
        hd: x,
        tl: filter(f, l0)
      };
    }
    _param = l0;
    continue;
  };
}

function succ(p) {
  if (/* tag */ typeof p === "number" || typeof p === "string") {
    return {
      TAG: /* XO */ 1,
      _0: /* XH */ 0
    };
  } else if (p.TAG === /* XI */ 0) {
    return {
      TAG: /* XO */ 1,
      _0: succ(p._0)
    };
  } else {
    return {
      TAG: /* XI */ 0,
      _0: p._0
    };
  }
}

function add(x, y) {
  if (/* tag */ typeof x === "number" || typeof x === "string") {
    if (/* tag */ typeof y === "number" || typeof y === "string") {
      return {
        TAG: /* XO */ 1,
        _0: /* XH */ 0
      };
    } else if (y.TAG === /* XI */ 0) {
      return {
        TAG: /* XO */ 1,
        _0: succ(y._0)
      };
    } else {
      return {
        TAG: /* XI */ 0,
        _0: y._0
      };
    }
  }
  if (x.TAG === /* XI */ 0) {
    const p = x._0;
    if (/* tag */ typeof y === "number" || typeof y === "string") {
      return {
        TAG: /* XO */ 1,
        _0: succ(p)
      };
    } else if (y.TAG === /* XI */ 0) {
      return {
        TAG: /* XO */ 1,
        _0: add_carry(p, y._0)
      };
    } else {
      return {
        TAG: /* XI */ 0,
        _0: add(p, y._0)
      };
    }
  }
  const p$1 = x._0;
  if (/* tag */ typeof y === "number" || typeof y === "string") {
    return {
      TAG: /* XI */ 0,
      _0: p$1
    };
  } else if (y.TAG === /* XI */ 0) {
    return {
      TAG: /* XI */ 0,
      _0: add(p$1, y._0)
    };
  } else {
    return {
      TAG: /* XO */ 1,
      _0: add(p$1, y._0)
    };
  }
}

function add_carry(x, y) {
  if (/* tag */ typeof x === "number" || typeof x === "string") {
    if (/* tag */ typeof y === "number" || typeof y === "string") {
      return {
        TAG: /* XI */ 0,
        _0: /* XH */ 0
      };
    } else if (y.TAG === /* XI */ 0) {
      return {
        TAG: /* XI */ 0,
        _0: succ(y._0)
      };
    } else {
      return {
        TAG: /* XO */ 1,
        _0: succ(y._0)
      };
    }
  }
  if (x.TAG === /* XI */ 0) {
    const p = x._0;
    if (/* tag */ typeof y === "number" || typeof y === "string") {
      return {
        TAG: /* XI */ 0,
        _0: succ(p)
      };
    } else if (y.TAG === /* XI */ 0) {
      return {
        TAG: /* XI */ 0,
        _0: add_carry(p, y._0)
      };
    } else {
      return {
        TAG: /* XO */ 1,
        _0: add_carry(p, y._0)
      };
    }
  }
  const p$1 = x._0;
  if (/* tag */ typeof y === "number" || typeof y === "string") {
    return {
      TAG: /* XO */ 1,
      _0: succ(p$1)
    };
  } else if (y.TAG === /* XI */ 0) {
    return {
      TAG: /* XO */ 1,
      _0: add_carry(p$1, y._0)
    };
  } else {
    return {
      TAG: /* XI */ 0,
      _0: add(p$1, y._0)
    };
  }
}

function pred_double(p) {
  if (/* tag */ typeof p === "number" || typeof p === "string") {
    return /* XH */ 0;
  } else if (p.TAG === /* XI */ 0) {
    return {
      TAG: /* XI */ 0,
      _0: {
        TAG: /* XO */ 1,
        _0: p._0
      }
    };
  } else {
    return {
      TAG: /* XI */ 0,
      _0: pred_double(p._0)
    };
  }
}

function compare_cont(_r, _x, _y) {
  while (true) {
    const y = _y;
    const x = _x;
    const r = _r;
    if (/* tag */ typeof x === "number" || typeof x === "string") {
      if (/* tag */ typeof y === "number" || typeof y === "string") {
        return r;
      } else {
        return /* Lt */ 1;
      }
    }
    if (x.TAG === /* XI */ 0) {
      const p = x._0;
      if (/* tag */ typeof y === "number" || typeof y === "string") {
        return /* Gt */ 2;
      }
      if (y.TAG === /* XI */ 0) {
        _y = y._0;
        _x = p;
        continue;
      }
      _y = y._0;
      _x = p;
      _r = /* Gt */ 2;
      continue;
    } else {
      const p$1 = x._0;
      if (/* tag */ typeof y === "number" || typeof y === "string") {
        return /* Gt */ 2;
      }
      if (y.TAG === /* XI */ 0) {
        _y = y._0;
        _x = p$1;
        _r = /* Lt */ 1;
        continue;
      }
      _y = y._0;
      _x = p$1;
      continue;
    }
  };
}

function compare(param, param$1) {
  return compare_cont(/* Eq */ 0, param, param$1);
}

const Pos = {
  succ: succ,
  add: add,
  add_carry: add_carry,
  pred_double: pred_double,
  compare_cont: compare_cont,
  compare: compare
};

function $$double(p) {
  if (/* tag */ typeof p === "number" || typeof p === "string") {
    return /* Z0 */ 0;
  } else if (p.TAG === /* Zpos */ 0) {
    return {
      TAG: /* Zpos */ 0,
      _0: {
        TAG: /* XO */ 1,
        _0: p._0
      }
    };
  } else {
    return {
      TAG: /* Zneg */ 1,
      _0: {
        TAG: /* XO */ 1,
        _0: p._0
      }
    };
  }
}

function succ_double(p) {
  if (/* tag */ typeof p === "number" || typeof p === "string") {
    return {
      TAG: /* Zpos */ 0,
      _0: /* XH */ 0
    };
  } else if (p.TAG === /* Zpos */ 0) {
    return {
      TAG: /* Zpos */ 0,
      _0: {
        TAG: /* XI */ 0,
        _0: p._0
      }
    };
  } else {
    return {
      TAG: /* Zneg */ 1,
      _0: pred_double(p._0)
    };
  }
}

function pred_double$1(p) {
  if (/* tag */ typeof p === "number" || typeof p === "string") {
    return {
      TAG: /* Zneg */ 1,
      _0: /* XH */ 0
    };
  } else if (p.TAG === /* Zpos */ 0) {
    return {
      TAG: /* Zpos */ 0,
      _0: pred_double(p._0)
    };
  } else {
    return {
      TAG: /* Zneg */ 1,
      _0: {
        TAG: /* XI */ 0,
        _0: p._0
      }
    };
  }
}

function pos_sub(x, y) {
  if (/* tag */ typeof x === "number" || typeof x === "string") {
    if (/* tag */ typeof y === "number" || typeof y === "string") {
      return /* Z0 */ 0;
    } else if (y.TAG === /* XI */ 0) {
      return {
        TAG: /* Zneg */ 1,
        _0: {
          TAG: /* XO */ 1,
          _0: y._0
        }
      };
    } else {
      return {
        TAG: /* Zneg */ 1,
        _0: pred_double(y._0)
      };
    }
  }
  if (x.TAG === /* XI */ 0) {
    const p = x._0;
    if (/* tag */ typeof y === "number" || typeof y === "string") {
      return {
        TAG: /* Zpos */ 0,
        _0: {
          TAG: /* XO */ 1,
          _0: p
        }
      };
    } else if (y.TAG === /* XI */ 0) {
      return $$double(pos_sub(p, y._0));
    } else {
      return succ_double(pos_sub(p, y._0));
    }
  }
  const p$1 = x._0;
  if (/* tag */ typeof y === "number" || typeof y === "string") {
    return {
      TAG: /* Zpos */ 0,
      _0: pred_double(p$1)
    };
  } else if (y.TAG === /* XI */ 0) {
    return pred_double$1(pos_sub(p$1, y._0));
  } else {
    return $$double(pos_sub(p$1, y._0));
  }
}

function add$1(x, y) {
  if (/* tag */ typeof x === "number" || typeof x === "string") {
    return y;
  }
  if (x.TAG === /* Zpos */ 0) {
    const x$p = x._0;
    if (/* tag */ typeof y === "number" || typeof y === "string") {
      return x;
    } else if (y.TAG === /* Zpos */ 0) {
      return {
        TAG: /* Zpos */ 0,
        _0: add(x$p, y._0)
      };
    } else {
      return pos_sub(x$p, y._0);
    }
  }
  const x$p$1 = x._0;
  if (/* tag */ typeof y === "number" || typeof y === "string") {
    return x;
  } else if (y.TAG === /* Zpos */ 0) {
    return pos_sub(y._0, x$p$1);
  } else {
    return {
      TAG: /* Zneg */ 1,
      _0: add(x$p$1, y._0)
    };
  }
}

function succ$1(x) {
  return add$1(x, {
    TAG: /* Zpos */ 0,
    _0: /* XH */ 0
  });
}

function pred(x) {
  return add$1(x, {
    TAG: /* Zneg */ 1,
    _0: /* XH */ 0
  });
}

function compare$1(x, y) {
  if (/* tag */ typeof x === "number" || typeof x === "string") {
    if (/* tag */ typeof y === "number" || typeof y === "string") {
      return /* Eq */ 0;
    } else if (y.TAG === /* Zpos */ 0) {
      return /* Lt */ 1;
    } else {
      return /* Gt */ 2;
    }
  } else if (x.TAG === /* Zpos */ 0) {
    if (/* tag */ typeof y === "number" || typeof y === "string" || y.TAG !== /* Zpos */ 0) {
      return /* Gt */ 2;
    } else {
      return compare_cont(/* Eq */ 0, x._0, y._0);
    }
  } else if (/* tag */ typeof y === "number" || typeof y === "string" || y.TAG === /* Zpos */ 0) {
    return /* Lt */ 1;
  } else {
    return compOpp(compare_cont(/* Eq */ 0, x._0, y._0));
  }
}

function leb(x, y) {
  const match = compare$1(x, y);
  switch (match) {
    case /* Eq */ 0 :
    case /* Lt */ 1 :
      return true;
    case /* Gt */ 2 :
      return false;
  }
}

function ltb(x, y) {
  const match = compare$1(x, y);
  switch (match) {
    case /* Lt */ 1 :
      return true;
    case /* Eq */ 0 :
    case /* Gt */ 2 :
      return false;
  }
}

function max(n, m) {
  const match = compare$1(n, m);
  switch (match) {
    case /* Lt */ 1 :
      return m;
    case /* Eq */ 0 :
    case /* Gt */ 2 :
      return n;
  }
}

function min(n, m) {
  const match = compare$1(n, m);
  switch (match) {
    case /* Eq */ 0 :
    case /* Lt */ 1 :
      return n;
    case /* Gt */ 2 :
      return m;
  }
}

const Z = {
  $$double: $$double,
  succ_double: succ_double,
  pred_double: pred_double$1,
  pos_sub: pos_sub,
  add: add$1,
  succ: succ$1,
  pred: pred,
  compare: compare$1,
  leb: leb,
  ltb: ltb,
  max: max,
  min: min
};

function lo(i) {
  return i.lo;
}

function hi(i) {
  return i.hi;
}

function in_intervalB(i, x) {
  if (leb(i.lo, x)) {
    return leb(x, i.hi);
  } else {
    return false;
  }
}

function interval_nonemptyB(i) {
  return leb(i.lo, i.hi);
}

const ContiguousDomainIntervals = {
  lo: lo,
  hi: hi,
  in_intervalB: in_intervalB,
  interval_nonemptyB: interval_nonemptyB
};

function universe(d) {
  return d.universe;
}

function intervals(d) {
  return d.intervals;
}

function mkDomain_norm(u, is) {
  return {
    universe: u,
    intervals: filter(interval_nonemptyB, is)
  };
}

const ContiguousDomainDomain = {
  universe: universe,
  intervals: intervals,
  mkDomain_norm: mkDomain_norm
};

function separatedB(a, b) {
  return ltb(add$1(a.hi, {
    TAG: /* Zpos */ 0,
    _0: /* XH */ 0
  }), b.lo);
}

function interval_union(a, b) {
  return {
    lo: min(a.lo, b.lo),
    hi: max(a.hi, b.hi)
  };
}

function insert_canon(_i, _param) {
  while (true) {
    const param = _param;
    const i = _i;
    if (!param) {
      return {
        hd: i,
        tl: /* [] */ 0
      };
    }
    const rest = param.tl;
    const j = param.hd;
    if (separatedB(i, j)) {
      return {
        hd: i,
        tl: {
          hd: j,
          tl: rest
        }
      };
    }
    if (separatedB(j, i)) {
      return {
        hd: j,
        tl: insert_canon(i, rest)
      };
    }
    _param = rest;
    _i = interval_union(i, j);
    continue;
  };
}

function normalize_intervals(param) {
  if (!param) {
    return /* [] */ 0;
  }
  const i = param.hd;
  const rs = normalize_intervals(param.tl);
  if (interval_nonemptyB(i)) {
    return insert_canon(i, rs);
  } else {
    return rs;
  }
}

const ContiguousDomainUnionCanon = {
  separatedB: separatedB,
  interval_union: interval_union,
  insert_canon: insert_canon,
  normalize_intervals: normalize_intervals
};

function lo$1(i) {
  return i.lo;
}

function hi$1(i) {
  return i.hi;
}

function in_intervalB$1(i, x) {
  if (leb(i.lo, x)) {
    return leb(x, i.hi);
  } else {
    return false;
  }
}

function interval_nonemptyB$1(i) {
  return leb(i.lo, i.hi);
}

function universe$1(d) {
  return d.universe;
}

function intervals$1(d) {
  return d.intervals;
}

function mkDomain_norm$1(u, is) {
  return {
    universe: u,
    intervals: filter(interval_nonemptyB, is)
  };
}

function separatedB$1(a, b) {
  return ltb(add$1(a.hi, {
    TAG: /* Zpos */ 0,
    _0: /* XH */ 0
  }), b.lo);
}

function interval_union$1(a, b) {
  return {
    lo: min(a.lo, b.lo),
    hi: max(a.hi, b.hi)
  };
}

function insert_canon$1(_i, _param) {
  while (true) {
    const param = _param;
    const i = _i;
    if (!param) {
      return {
        hd: i,
        tl: /* [] */ 0
      };
    }
    const rest = param.tl;
    const j = param.hd;
    if (separatedB$1(i, j)) {
      return {
        hd: i,
        tl: {
          hd: j,
          tl: rest
        }
      };
    }
    if (separatedB$1(j, i)) {
      return {
        hd: j,
        tl: insert_canon$1(i, rest)
      };
    }
    _param = rest;
    _i = interval_union$1(i, j);
    continue;
  };
}

function normalize_intervals$1(param) {
  if (!param) {
    return /* [] */ 0;
  }
  const i = param.hd;
  const rs = normalize_intervals$1(param.tl);
  if (interval_nonemptyB(i)) {
    return insert_canon$1(i, rs);
  } else {
    return rs;
  }
}

function isEmpty(d) {
  const match = d.intervals;
  if (match) {
    return false;
  } else {
    return true;
  }
}

function isDefinedAt(d, x) {
  return existsb((function (i) {
    return in_intervalB(i, x);
  }), d.intervals);
}

function ofInterval(u, v) {
  return mkDomain_norm({
    hd: u,
    tl: /* [] */ 0
  }, {
    hd: v,
    tl: /* [] */ 0
  });
}

function union(a, b) {
  const rs = normalize_intervals(app(a.intervals, b.intervals));
  return {
    universe: rs,
    intervals: rs
  };
}

function intersect_interval(a, b) {
  return {
    lo: max(a.lo, b.lo),
    hi: min(a.hi, b.hi)
  };
}

function intersection(a, b) {
  const rs = flat_map((function (ia) {
    return flat_map((function (ib) {
      return {
        hd: intersect_interval(ia, ib),
        tl: /* [] */ 0
      };
    }), b.intervals);
  }), a.intervals);
  return mkDomain_norm(a.universe, rs);
}

function subtract_interval(a, b) {
  if (ltb(b.hi, a.lo) || ltb(a.hi, b.lo)) {
    return {
      hd: a,
      tl: /* [] */ 0
    };
  }
  const left = ltb(a.lo, b.lo) ? ({
      hd: {
        lo: a.lo,
        hi: add$1(b.lo, {
          TAG: /* Zneg */ 1,
          _0: /* XH */ 0
        })
      },
      tl: /* [] */ 0
    }) : /* [] */ 0;
  const right = ltb(b.hi, a.hi) ? ({
      hd: {
        lo: add$1(b.hi, {
          TAG: /* Zpos */ 0,
          _0: /* XH */ 0
        }),
        hi: a.hi
      },
      tl: /* [] */ 0
    }) : /* [] */ 0;
  return app(left, right);
}

function subtract_intervals(_as_, _param) {
  while (true) {
    const param = _param;
    const as_ = _as_;
    if (!param) {
      return as_;
    }
    const b = param.hd;
    const as1 = flat_map((function (a) {
      return subtract_interval(a, b);
    }), as_);
    _param = param.tl;
    _as_ = as1;
    continue;
  };
}

function difference(a, b) {
  return mkDomain_norm(a.universe, subtract_intervals(a.intervals, b.intervals));
}

function complement(d) {
  return mkDomain_norm(d.universe, subtract_intervals(d.universe, d.intervals));
}

function isSubsetOf(a, b) {
  return isEmpty(difference(a, b));
}

function isSupersetOf(a, b) {
  return isEmpty(difference(b, a));
}

function equals(a, b) {
  if (isEmpty(difference(a, b))) {
    return isEmpty(difference(b, a));
  } else {
    return false;
  }
}

const ContiguousDomain = {
  lo: lo$1,
  hi: hi$1,
  in_intervalB: in_intervalB$1,
  interval_nonemptyB: interval_nonemptyB$1,
  universe: universe$1,
  intervals: intervals$1,
  mkDomain_norm: mkDomain_norm$1,
  separatedB: separatedB$1,
  interval_union: interval_union$1,
  insert_canon: insert_canon$1,
  normalize_intervals: normalize_intervals$1,
  isEmpty: isEmpty,
  isDefinedAt: isDefinedAt,
  ofInterval: ofInterval,
  union: union,
  intersect_interval: intersect_interval,
  intersection: intersection,
  subtract_interval: subtract_interval,
  subtract_intervals: subtract_intervals,
  difference: difference,
  complement: complement,
  isSubsetOf: isSubsetOf,
  isSupersetOf: isSupersetOf,
  equals: equals
};

const CD = ContiguousDomain;

module.exports = {
  app,
  compOpp,
  flat_map,
  existsb,
  filter,
  Pos,
  Z,
  ContiguousDomainIntervals,
  ContiguousDomainDomain,
  ContiguousDomainUnionCanon,
  ContiguousDomain,
  CD,
}
/* No side effect */
