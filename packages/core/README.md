# @janus-validator/core

Core validation library for Janus Validator - composable validators that can both **validate data** and **generate valid examples**. Perfect for testing, API validation, and form handling.

üöß **Pre-1.0 notice:** This package has **not** reached `1.0` yet. Until then, the public API and behavior are **subject to change** between releases. If you need stability, **pin exact versions**.

## Features

- üéØ **Type-safe validation** with clear, helpful error messages
- üß¨ **Structured, recursive errors** (per-field / per-index) with generated examples
- üé≤ **Automatic data generation** from validator definitions (great for tests/fixtures)
- üß© **Composable combinators** for complex schemas
- üé≠ **Realistic presets** for names, emails, addresses, etc.
- üîß **Custom generators** to override default generation
- üìù **Optional concise DSL** available in [@janus-validator/dsl](../dsl/README.md)

## Installation

```bash
# Core + DSL package (recommended)
npm install @janus-validator/core @janus-validator/dsl

# Or just core (no DSL)
npm install @janus-validator/core
```

## Quick Start

This demonstrates usage without the DSL, although usable, it's generally recommended you use the DSL. They are functionally equivalent, just the syntax is shorter and cleaner.

```typescript
import { Generator } from '@janus-validator/core';
import {
  Struct,
  UnicodeString,
  Integer,
  Boolean,
  Regex,
} from '@janus-validator/core/combinators';

// Define a validator (core API)
const userValidator = Struct({
  name: UnicodeString(1, 100),
  age: Integer(0, 150),
  email: Regex(/^[\w.]+@[\w.]+\.\w+$/),
  active: Boolean(),
});

// Validate data
const result = userValidator.validate({
  name: 'Alice',
  age: 30,
  email: 'alice@example.com',
  active: true,
});

if (result.valid) {
  console.log('Valid:', result.value);
} else {
  console.log('Error:', result.error);
  console.log('Example:', result.example); // Auto-generated valid example
}

// Generate test data
const generator = new Generator({ random: Math.random });
const testUser = generator.generate(userValidator.domain);
// { name: 'Alice', age: 42, email: 'test@example.com', active: true }
```

## The ‚Äútwo faces‚Äù: validate + generate

Janus validators can be used in both directions:

- Forwards: `validator.validate(unknown)` ‚Üí `ValidationResult<T>`
- Backwards: `generator.generate(validator.domain)` ‚Üí `T`

This enables ‚Äúround-trip‚Äù testing: anything generated by a validator should validate.

```typescript
import { Generator } from '@janus-validator/core';
import { Struct, UnicodeString, Integer } from '@janus-validator/core/combinators';

const User = Struct({ name: UnicodeString(1, 50), age: Integer(0, 150) });
const generator = new Generator({ random: Math.random });

const sample = generator.generate(User.domain);
const result = User.validate(sample);
// result.valid === true
```

## Structured errors (with examples)

When validation fails, you get:
- `error`: human-readable error message
- `path` / `pathString`: exact location (e.g. `['profile', 'age']` ‚Üí `'profile.age'`)
- `code`: optional error code for i18n
- `results`: a recursive structure showing which parts passed/failed
- `example`: an auto-generated valid value for the failing validator

```typescript
import { Struct, UnicodeString, Integer } from '@janus-validator/core/combinators';
import { flattenErrors, formatErrors, errorsToJson } from '@janus-validator/core';

const Profile = Struct({ name: UnicodeString(1, 50), age: Integer(0, 150) });
const result = Profile.validate({ name: 'Alice', age: 999 });

if (!result.valid) {
  result.error;       // "age: Expected value <= 150, got 999"
  result.path;        // ['age']
  result.pathString;  // 'age'
  result.results;     // per-field ValidationResult
  result.example;     // generated valid Profile
  
  // Error formatting utilities
  const errors = flattenErrors(result);  // [{ path: 'age', message: '...', code: undefined }]
  const text = formatErrors(result);     // "age: Expected value <= 150, got 999"
  const json = errorsToJson(result);     // { valid: false, errors: [...] }
}
```

## Validator Modifiers

Chain modifiers for common validation patterns:

### Optional / Nullable / Default

```typescript
import { UnicodeString, Integer, Boolean } from '@janus-validator/core/combinators';

// Accept undefined in addition to the normal type
const maybeName = UnicodeString(1, 50).optional();     // string | undefined

// Accept null in addition to the normal type  
const nullableName = UnicodeString(1, 50).nullable();  // string | null

// Accept null or undefined
const nullishName = UnicodeString(1, 50).nullish();    // string | null | undefined

// Provide default value for undefined inputs
const port = Integer(1, 65535).default(3000);
const timestamp = Integer().default(() => Date.now());  // Dynamic default
```

### Transforms

```typescript
import { UnicodeString } from '@janus-validator/core/combinators';

// Built-in string transforms
const normalized = UnicodeString(1, 100)
  .trim()
  .toLowerCase();

// Custom transforms
const toInt = UnicodeString(1, 10)
  .transform(s => parseInt(s, 10));  // Validator<number>
```

### Refinements

```typescript
import { UnicodeString, Integer } from '@janus-validator/core/combinators';

// Simple predicate refinement
const even = Integer(0, 100).refine(n => n % 2 === 0, 'Must be even');

// Dynamic error message
const positive = Integer().refine(
  n => n > 0,
  n => `Expected positive, got ${n}`
);

// Multiple refinements
const password = UnicodeString(8, 100)
  .refine(s => /[A-Z]/.test(s), 'Must contain uppercase')
  .refine(s => /[0-9]/.test(s), 'Must contain digit');

// Complex validation with superRefine
const form = Struct({
  password: UnicodeString(8, 100),
  confirm: UnicodeString(8, 100),
}).superRefine((value, ctx) => {
  if (value.password !== value.confirm) {
    ctx.addIssue({ message: 'Passwords must match', path: ['confirm'] });
  }
});
```

### Error Customization

```typescript
import { UnicodeString } from '@janus-validator/core/combinators';

const email = UnicodeString(5, 100)
  .refine(s => s.includes('@'))
  .message('Please enter a valid email')   // Custom error message
  .code('INVALID_EMAIL')                   // Error code for i18n
  .describe('User email address');         // Documentation

// Dynamic message
const count = Integer(1, 100).message((err, val) => 
  `Count ${val} is invalid: ${err}`
);
```

## Error Formatting Utilities

```typescript
import { 
  flattenErrors,    // Get all errors as flat array
  formatErrors,     // Human-readable string
  errorsToJson,     // JSON for API responses
  getFirstError,    // Get first error only
  getErrorAtPath,   // Find error at specific path
  getErrorsByPath,  // Group errors by path
} from '@janus-validator/core';

const result = User.validate(data);
if (!result.valid) {
  // Flat array for form handling
  const errors = flattenErrors(result);
  // [{ path: 'profile.email', message: 'Invalid', code: 'INVALID_EMAIL' }]
  
  // Human-readable for logging
  console.log(formatErrors(result));
  // "profile.email: Invalid"
  
  // JSON for API responses
  res.status(400).json(errorsToJson(result));
  // { valid: false, errors: [{ path: '...', message: '...', code: '...' }] }
  
  // Form field error
  const emailError = getErrorAtPath(result, 'profile.email');
  if (emailError) setFieldError('email', emailError.message);
}
```

## DSL

The DSL lives in a separate package: [@janus-validator/dsl](../dsl/README.md).
It provides short aliases (`O`, `U`, `I`, `B`, `Or`, `Seq`, ‚Ä¶) plus primitive/enum auto-wrapping.

## Realistic Data Presets

Generate realistic test data:

```typescript
import {
  FirstName, LastName, FullName,
  RealisticEmail, CorporateEmailPreset,
  RealisticUSPhone,
  RealisticStreetAddress, RealisticCity, RealisticState, RealisticZipCode,
  CompanyName, ProductName,
  RecentDate, FutureDate,
  RealisticPrice,
} from '@janus-validator/core/lib';
import { O } from '@janus-validator/dsl';
import { Generator } from '@janus-validator/core';

const generator = new Generator({ random: Math.random });

const customer = O({
  name: FullName(),           // "Alice Smith"
  email: RealisticEmail(),    // "alice.smith@gmail.com"
  phone: RealisticUSPhone(),  // "(555) 123-4567"
  address: O({
    street: RealisticStreetAddress(), // "1234 Oak St"
    city: RealisticCity(),            // "New York"
    state: RealisticState(),          // "NY"
    zip: RealisticZipCode(),          // "10001"
  }),
});

const testCustomer = generator.generate(customer.domain);
```

## Custom Generators

Override default generation with custom logic:

```typescript
import { fromValues, templateGenerator, withGenerator } from '@janus-validator/core/combinators';
import { U, I, R } from '@janus-validator/dsl';

// Generate from a fixed list
const country = fromValues(R(/^[A-Z]{2}$/), ['US', 'CA', 'GB', 'DE', 'FR']);

// Template-based generation
const sku = templateGenerator(U(10, 20), (pick, rng) => {
  const categories = ['ELEC', 'FURN', 'CLTH'];
  const num = Math.floor(rng.random() * 10000).toString().padStart(4, '0');
  return `${pick(categories)}-${num}`;
});
// Generates: "ELEC-0042", "FURN-1337", etc.

// Custom generation function
const userId = withGenerator(I(1, 1000000), (rng) => {
  return Math.floor(rng.random() * 1000000) + 1;
});
```

## Error Messages with Examples

All DSL validators automatically include valid examples in error messages:

```typescript
import { I } from '@janus-validator/dsl';

const age = I(18, 100);
const result = age.validate('not a number');

// result = {
//   valid: false,
//   error: 'Expected number, got string',
//   example: 42  // Auto-generated valid example
// }
```

## Real-World Examples

### API Request Validation

```typescript
import { O, U, I, R, Or, Null } from '@janus-validator/dsl';

const createUserRequest = O({
  username: R(/^[a-zA-Z][a-zA-Z0-9_]{2,19}$/),
  email: R(/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/),
  password: U(8, 128),
  profile: O({
    firstName: U(1, 50),
    lastName: U(1, 50),
    age: Or(I(13, 150), Null()),
  }),
});

// In your API handler
const result = createUserRequest.validate(req.body);
if (!result.valid) {
  return res.status(400).json({ error: result.error });
}
```

### Form Validation

```typescript
import { O, U, R } from '@janus-validator/dsl';

const signupForm = O({
  email: R(/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/),
  password: U(8, 100),
  acceptTerms: true, // Must be true (auto-wrapped)
});

const result = signupForm.validate(data);
if (!result.valid) {
  console.error(result.error);
}
```

### E-Commerce Order

```typescript
import { O, U, I, N, R, Or, oneOrMore } from '@janus-validator/dsl';

const orderItem = O({
  productId: U(10, 50),
  name: U(1, 200),
  quantity: I(1, 100),
  unitPrice: N(0.01, 100000),
});

const order = O({
  orderId: R(/^ORD-\d{8}$/),
  customerId: I(1, 1000000),
  items: oneOrMore(orderItem),
  subtotal: N(0, 1000000),
  tax: N(0, 100000),
  total: N(0, 1100000),
  status: Or('pending', 'processing', 'shipped', 'delivered'), // Auto-wrapped!
  createdAt: R(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/),
});
```

### Test Data Generation

```typescript
import { Generator } from '@janus-validator/core';

const rng = { random: Math.random };
const generator = new Generator(rng);

// Generate 100 test users
const testUsers = Array.from({ length: 100 }, () => 
  generator.generate(userValidator.domain)
);

// Use in tests
describe('UserService', () => {
  it('should create users', () => {
    const user = generator.generate(userValidator.domain);
    const created = userService.create(user);
    expect(created.id).toBeDefined();
  });
});
```

## API Reference

### Validator Interface

```typescript
interface Validator<T, D extends Domain<T>> {
  validate(input: unknown): ValidationResult<T>;
  domain: D;
}

type ValidationResult<T> =
  | { valid: true; value: T }
  | {
      valid: false;
      error: string;
      path?: (string | number)[];     // Error location: ['user', 'email']
      pathString?: string;            // Formatted: 'user.email'
      code?: string;                  // Error code for i18n
      meta?: Record<string, unknown>; // Additional metadata
      example?: T;                    // Auto-generated valid example
      results?: { [key: string]: ValidationResult<unknown> } | ValidationResult<unknown>[];
    };
```

### Domain Interface

```typescript
interface Domain<T> {
  readonly kind: DomainType;
  contains(value: unknown): value is T;
}
```

### Type Utilities

Helper types for working with validators:

```typescript
import {
  InferValidatorType,   // Extract T from Validator<T, D>
  UnionOfValidators,    // [Validator<A, DA>, Validator<B, DB>] => A | B
  TupleOfValidators,    // [Validator<A, DA>, Validator<B, DB>] => [A, B]
  ValidatorSchema,      // { [key: string]: Validator<unknown, Domain<unknown>> }
  InferSchemaType,      // { a: Validator<A, DA> } => { a: A }
} from '@janus-validator/core';

// Example: Infer type from any validator
type UserType = InferValidatorType<typeof userValidator>;
```

### Generator Class

```typescript
class Generator {
  constructor(rng: RNG);
  generate<T>(domain: Domain<T>): T;
}

interface RNG {
  random(): number; // Returns 0-1
}
```

## License

MIT
