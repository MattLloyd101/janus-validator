import { Generator, RNG, Validator, Domain } from '@/com/techlloyd/janus/index';
import {
  Boolean,
  UnicodeString,
  Integer,
  Float,
  Long,
  Bytes,
  Regex,
  Struct,
  Alternation,
  Sequence,
  Quantifier,
  Null,
  Undefined,
  Constant,
} from '@/com/techlloyd/janus/combinators';

/**
 * Property-based test: Any value generated by a Generator<T> (via Domain)
 * must pass validation by its corresponding Validator<T>
 * 
 * Property: âˆ€ validator, validate(generator.generate(validator.domain)) === valid
 */
describe('Property: Generated values always pass validation', () => {
  const rng: RNG = {
    random: () => Math.random(),
  };
  const generator = new Generator(rng);

  describe('Primitive validators', () => {
    it('Boolean', () => {
      const validator = Boolean();
      for (let i = 0; i < 100; i++) {
        const value = generator.generate(validator.domain);
        expect(validator.validate(value).valid).toBe(true);
      }
    });

    it('String', () => {
      const validators = [
        UnicodeString(),
        UnicodeString(0, 10),
        UnicodeString(5, 20),
        UnicodeString(1, 5),
      ];
      for (const validator of validators) {
        for (let i = 0; i < 100; i++) {
          const value = generator.generate(validator.domain);
          expect(validator.validate(value).valid).toBe(true);
        }
      }
    });

    it('Integer', () => {
      const validators = [
        Integer(),
        Integer(0, 100),
        Integer(-50, 50),
        Integer(42, 42), // single value
      ];
      for (const validator of validators) {
        for (let i = 0; i < 100; i++) {
          const value = generator.generate(validator.domain);
          expect(validator.validate(value).valid).toBe(true);
        }
      }
    });

    it('Number (float)', () => {
      const validators = [
        Float(0, 1000),
        Float(0, 1),
        Float(-100, 100),
      ];
      for (const validator of validators) {
        for (let i = 0; i < 100; i++) {
          const value = generator.generate(validator.domain);
          expect(validator.validate(value).valid).toBe(true);
        }
      }
    });

    it('Long (bigint)', () => {
      const validators = [
        Long(),
        Long(0n, 1000n),
        Long(-1000n, 1000n),
        Long(42n, 42n), // single value
      ];
      for (const validator of validators) {
        for (let i = 0; i < 100; i++) {
          const value = generator.generate(validator.domain);
          expect(validator.validate(value).valid).toBe(true);
        }
      }
    });

    it('Bytes (binary)', () => {
      const validators = [
        Bytes(),
        Bytes(0, 10),
        Bytes(16, 16), // fixed length
        Bytes(32, 32), // SHA-256 size
      ];
      for (const validator of validators) {
        for (let i = 0; i < 100; i++) {
          const value = generator.generate(validator.domain);
          expect(validator.validate(value).valid).toBe(true);
        }
      }
    });

    it('Regex', () => {
      // Note: Use explicit character classes (no \d, \w, \s) for portability
      const validators = [
        Regex(/^hello$/),
        Regex(/^[0-9]{3}-[0-9]{4}$/),
        Regex(/^[a-z]+@[a-z]+\.[a-z]{2,3}$/),
        Regex(/^(foo|bar|baz)+$/),
        Regex(/^#[0-9a-f]{6}$/),
        Regex(/^[A-Za-z0-9_]{5,10}$/),
        Regex(/^[A-Z][a-z]+$/),
      ];
      for (const validator of validators) {
        for (let i = 0; i < 100; i++) {
          const value = generator.generate(validator.domain);
          expect(validator.validate(value).valid).toBe(true);
        }
      }
    });
  });

  describe('Special values', () => {
    it('Null', () => {
      const validator = Null();
      for (let i = 0; i < 10; i++) {
        const value = generator.generate(validator.domain);
        expect(validator.validate(value).valid).toBe(true);
        expect(value).toBe(null);
      }
    });

    it('Undefined', () => {
      const validator = Undefined();
      for (let i = 0; i < 10; i++) {
        const value = generator.generate(validator.domain);
        expect(validator.validate(value).valid).toBe(true);
        expect(value).toBe(undefined);
      }
    });

    it('Constant', () => {
      const validators: Validator<any, Domain<any>>[] = [
        Constant(42),
        Constant('hello'),
        Constant(true),
      ];
      for (const validator of validators) {
        for (let i = 0; i < 10; i++) {
          const value = generator.generate(validator.domain);
          expect(validator.validate(value).valid).toBe(true);
        }
      }
    });
  });

  describe('Composite validators', () => {
    it('Struct', () => {
      const validators: Validator<any, Domain<any>>[] = [
        Struct({ name: UnicodeString(1, 50), age: Integer(0, 150) }),
        Struct({ x: Integer(), y: Integer() }),
        Struct({ nested: Struct({ value: Boolean() }) }),
      ];
      for (const validator of validators) {
        for (let i = 0; i < 100; i++) {
          const value = generator.generate(validator.domain);
          expect(validator.validate(value).valid).toBe(true);
        }
      }
    });

    it('Alternation', () => {
      // Union types are properly inferred: Validator<string | number>, etc.
      const stringOrNumber = Alternation.of(UnicodeString(), Integer());
      const boolOrNull = Alternation.of(Boolean(), Null());
      const abc = Alternation.of(Constant('a'), Constant('b'), Constant('c'));
      
      const validators: Validator<any, Domain<any>>[] = [stringOrNumber, boolOrNull, abc];
      for (const validator of validators) {
        for (let i = 0; i < 100; i++) {
          const value = generator.generate(validator.domain);
          expect(validator.validate(value).valid).toBe(true);
        }
      }
    });

    it('Sequence', () => {
      const validators: Validator<any, Domain<any>>[] = [
        Sequence.of(UnicodeString(), Integer(), Boolean()),
        Sequence.of(Integer(), Integer()),
      ];
      for (const validator of validators) {
        for (let i = 0; i < 100; i++) {
          const value = generator.generate(validator.domain);
          expect(validator.validate(value).valid).toBe(true);
        }
      }
    });

    it('Quantifier', () => {
      const validators: Validator<any, Domain<any>>[] = [
        Quantifier.zeroOrMore(Integer(0, 10)),
        Quantifier.oneOrMore(UnicodeString(1, 5)),
        Quantifier.optional(Boolean()),
        Quantifier.exactly(Integer(), 3),
        Quantifier.between(UnicodeString(), 2, 5),
      ];
      for (const validator of validators) {
        for (let i = 0; i < 100; i++) {
          const value = generator.generate(validator.domain);
          expect(validator.validate(value).valid).toBe(true);
        }
      }
    });
  });

  describe('Complex nested structures', () => {
    it('API response structure', () => {
      const Item = Struct({
        id: Integer(1, 10000),
        name: UnicodeString(1, 100),
        price: Float(0, 1000),
      });

      const Response = Struct({
        success: Boolean(),
        items: Quantifier.zeroOrMore(Item),
        total: Integer(0, 1000000),
      });

      for (let i = 0; i < 50; i++) {
        const value = generator.generate(Response.domain);
        expect(Response.validate(value).valid).toBe(true);
      }
    });

    it('Union types', () => {
      // Type is inferred as Validator<string | number | null>
      const StringOrNumberOrNull = Alternation.of(
        UnicodeString(1, 20),
        Integer(0, 100),
        Null()
      );

      for (let i = 0; i < 100; i++) {
        const value = generator.generate(StringOrNumberOrNull.domain);
        expect(StringOrNumberOrNull.validate(value).valid).toBe(true);
      }
    });
  });
});

