import fc from 'fast-check';
import { Generator, RNG } from '@/com/techlloyd/janus/index';
import { Integer } from '@/com/techlloyd/janus/combinators/Integer';
import { Float } from '@/com/techlloyd/janus/combinators/Float';
import { UnicodeString } from '@/com/techlloyd/janus/combinators/UnicodeString';
import { Boolean } from '@/com/techlloyd/janus/combinators/Boolean';
import { Struct } from '@/com/techlloyd/janus/combinators/Struct';
import { Quantifier } from '@/com/techlloyd/janus/combinators/Quantifier';
import { Regex } from '@/com/techlloyd/janus/combinators/Regex';
import { Sequence } from '@/com/techlloyd/janus/combinators/Sequence';
import { Constant } from '@/com/techlloyd/janus/combinators/Constant';
import { Alternation } from '@/com/techlloyd/janus/combinators/Alternation';

/**
 * Property-based tests ensuring the "round-trip" property:
 * Any value generated by a validator should pass validation.
 * 
 * This is a fundamental invariant: generate(domain) â†’ validate(value) === success
 */
describe('Round-trip property: generated values always validate', () => {
  const NUM_RUNS = 50;
  const rng: RNG = { random: Math.random };
  const generator = new Generator(rng);

  it('Integer: generated values pass validation', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: -1_000_000, max: 1_000_000 }),
        fc.integer({ min: -1_000_000, max: 1_000_000 }),
        (a, b) => {
          const min = Math.min(a, b);
          const max = Math.max(a, b);
          const validator = Integer(min, max);
          
          for (let i = 0; i < 10; i++) {
            const value = generator.generate(validator.domain);
            const result = validator.validate(value);
            expect(result.valid).toBe(true);
            if (result.valid) {
              expect(value).toBeGreaterThanOrEqual(min);
              expect(value).toBeLessThanOrEqual(max);
            }
          }
        }
      ),
      { numRuns: NUM_RUNS }
    );
  });

  it('Float: generated values pass validation', () => {
    fc.assert(
      fc.property(
        fc.double({ min: -1_000_000, max: 1_000_000, noNaN: true }),
        fc.double({ min: -1_000_000, max: 1_000_000, noNaN: true }),
        (a, b) => {
          const min = Math.min(a, b);
          const max = Math.max(a, b);
          const validator = Float(min, max);
          
          for (let i = 0; i < 10; i++) {
            const value = generator.generate(validator.domain);
            const result = validator.validate(value);
            expect(result.valid).toBe(true);
          }
        }
      ),
      { numRuns: NUM_RUNS }
    );
  });

  it('UnicodeString: generated values pass validation', () => {
    fc.assert(
      fc.property(
        fc.nat({ max: 20 }),
        fc.nat({ max: 100 }),
        (a, b) => {
          const minLength = Math.min(a, b);
          const maxLength = Math.max(a, b, minLength + 1); // ensure max > min
          const validator = UnicodeString(minLength, maxLength);
          
          for (let i = 0; i < 10; i++) {
            const value = generator.generate(validator.domain);
            const result = validator.validate(value);
            expect(result.valid).toBe(true);
            if (result.valid) {
              expect(value.length).toBeGreaterThanOrEqual(minLength);
              expect(value.length).toBeLessThanOrEqual(maxLength);
            }
          }
        }
      ),
      { numRuns: NUM_RUNS }
    );
  });

  it('Boolean: generated values pass validation', () => {
    const validator = Boolean();
    for (let i = 0; i < 100; i++) {
      const value = generator.generate(validator.domain);
      const result = validator.validate(value);
      expect(result.valid).toBe(true);
      expect(typeof value).toBe('boolean');
    }
  });

  it('Struct: generated values pass validation', () => {
    fc.assert(
      fc.property(
        fc.nat({ max: 50 }),
        fc.nat({ max: 100 }),
        (strLen, ageMax) => {
          const validator = Struct({
            name: UnicodeString(1, Math.max(strLen, 1)),
            age: Integer(0, Math.max(ageMax, 1)),
            active: Boolean(),
          });
          
          for (let i = 0; i < 5; i++) {
            const value = generator.generate(validator.domain);
            const result = validator.validate(value);
            expect(result.valid).toBe(true);
          }
        }
      ),
      { numRuns: NUM_RUNS }
    );
  });

  it('Quantifier: generated values pass validation', () => {
    fc.assert(
      fc.property(
        fc.nat({ max: 5 }),
        fc.nat({ max: 10 }),
        (a, b) => {
          const min = Math.min(a, b);
          const max = Math.max(a, b, min);
          const validator = new Quantifier(Integer(0, 100), min, max);
          
          for (let i = 0; i < 5; i++) {
            const value = generator.generate(validator.domain);
            const result = validator.validate(value);
            expect(result.valid).toBe(true);
            if (result.valid) {
              expect(value.length).toBeGreaterThanOrEqual(min);
              expect(value.length).toBeLessThanOrEqual(max);
            }
          }
        }
      ),
      { numRuns: NUM_RUNS }
    );
  });

  it('Regex: generated values pass validation', () => {
    const patterns = [
      /^[a-z]+$/,
      /^[0-9]{3,5}$/,
      /^[A-Z][a-z]*$/,
      /^(foo|bar|baz)$/,
      /^[a-zA-Z0-9_]+$/,
    ];

    for (const pattern of patterns) {
      const validator = Regex(pattern);
      for (let i = 0; i < 20; i++) {
        const value = generator.generate(validator.domain);
        const result = validator.validate(value);
        expect(result.valid).toBe(true);
      }
    }
  });

  it('Sequence: generated values pass validation', () => {
    const validator = new Sequence(
      Integer(0, 100),
      UnicodeString(1, 10),
      Boolean()
    );

    for (let i = 0; i < 50; i++) {
      const value = generator.generate(validator.domain);
      const result = validator.validate(value);
      expect(result.valid).toBe(true);
    }
  });

  it('Constant: generated values pass validation', () => {
    const constants = [42, 'hello', true, null, undefined];
    
    for (const c of constants) {
      const validator = Constant(c);
      for (let i = 0; i < 10; i++) {
        const value = generator.generate(validator.domain);
        const result = validator.validate(value);
        expect(result.valid).toBe(true);
        expect(value).toBe(c);
      }
    }
  });

  it('Alternation: generated values pass validation', () => {
    const validator = Alternation.of(
      Constant('a'),
      Constant('b'),
      Constant('c'),
      Integer(1, 10)
    );

    for (let i = 0; i < 50; i++) {
      const value = generator.generate(validator.domain);
      const result = validator.validate(value);
      expect(result.valid).toBe(true);
    }
  });
});

describe('Edge case properties', () => {
  const rng: RNG = { random: Math.random };
  const generator = new Generator(rng);

  it('Integer at boundaries generates valid values', () => {
    const validator = Integer(Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
    for (let i = 0; i < 100; i++) {
      const value = generator.generate(validator.domain);
      expect(validator.validate(value).valid).toBe(true);
    }
  });

  it('Empty Sequence generates empty array', () => {
    const validator = new Sequence();
    const value = generator.generate(validator.domain);
    expect(value).toEqual([]);
    expect(validator.validate(value).valid).toBe(true);
  });

  it('Quantifier with min=0 can generate empty array', () => {
    const validator = Quantifier.zeroOrMore(Integer(0, 10));
    let foundEmpty = false;
    for (let i = 0; i < 100; i++) {
      const value = generator.generate(validator.domain);
      expect(validator.validate(value).valid).toBe(true);
      if (value.length === 0) foundEmpty = true;
    }
    // With random generation, we should sometimes get empty arrays
    // (not guaranteed, but very likely in 100 tries)
  });

  it('UnicodeString with minLength=0 can generate empty string', () => {
    const validator = UnicodeString(0, 10);
    let foundEmpty = false;
    for (let i = 0; i < 100; i++) {
      const value = generator.generate(validator.domain);
      expect(validator.validate(value).valid).toBe(true);
      if (value.length === 0) foundEmpty = true;
    }
  });

  it('Nested Struct generates valid nested objects', () => {
    const validator = Struct({
      level1: Struct({
        level2: Struct({
          value: Integer(0, 100),
        }),
      }),
    });

    for (let i = 0; i < 20; i++) {
      const value = generator.generate(validator.domain);
      const result = validator.validate(value);
      expect(result.valid).toBe(true);
      if (result.valid) {
        expect(typeof value.level1.level2.value).toBe('number');
      }
    }
  });
});

